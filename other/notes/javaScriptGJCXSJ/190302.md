# javaScript高级程序设计（第三版）笔记 - 05
## js两种数据类型：基本类型和引用类型
> 基本类型：Undefined，Null，Boolean，Number和string；引用类型Object类型、Function类型、Array类型、Date类型、基本包装类型、内置对象，大多数引用类型值都是Object类型的实例；

1. 基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中
2. 从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本
3. 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针；
4. 确定一个值是哪种基本类型可以使用typeof操作符，而确定一个值是哪种引用类型可以使用instanceof操作符。其中typeof null === “object”，是个bug；不同的对象在底层都表示为二进制，在 JavaScript 中二进制前三位都为 0 的话会被判断为 object 类型， null 的二进制表示是全 0，自然前三位也是 0，所以执行 typeof 时会返回“ object ”。

## 执行环境
> 所有变量（包括基本类型和引用类型）都存在于一个执行环境（也称为作用域）当中，这个执行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量。

1. 执行环境有全局执行环境（也称为全局环境）和函数执行环境之分；浏览器是window，node是global；
2. 每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链；
3. 函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其包含（父）环境，乃至全局环境；
4. 全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据；
5. 变量的执行环境有助于确定应该何时释放内存。

## 垃圾清理
1. 离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除。
2. 　“标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然后再回收其内存。到目前为止，IE、Firefox、Opera、Chrome、Safari的js实现使用的都是标记清除的垃圾回收策略或类似的策略，只不过垃圾收集的时间间隔互不相同。
3. IE老浏览器另一种垃圾收集算法是“引用计数”，这种算法的思想是跟踪记录所有值被引用的次数。JavaScript引擎目前都不再使用这种算法；但在IE中访问非原生JavaScript对象（如DOM元素）时，这种算法仍然可能会导致问题。
```
// 执行环境
function test(){
    var a = 10 ; //被标记 ，进入环境 
    var b = 20 ; //被标记 ，进入环境
}
test(); //执行完毕 之后 a、b又被标离开环境，被回收。
```
