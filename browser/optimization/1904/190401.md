
# 回流与重绘
> [当服务器经过请求](https://www.tomz.club/blog/md/FullStack/http/2020-04/180702.md),获得html文件时,会进行html解析

## html解析五个步骤
> 不包含js

1. 处理 HTML 标记并构建 DOM Tree。
2. 处理 CSS 标记并构建 CSS Rule Tree。
3. 将 DOM 与 CSSOM 合并成一个渲染树。
4. 根据渲染树（Render-Tree）来布局（layout），以计算每个节点的几何信息。
5. 将各个节点绘制（painting）到屏幕上

## html解析渲染模式：阻塞
1. 浏览器开始解析目标HTML文件,执行流的顺序为自上而下,并行加载（图片、js、css都属于静态资源，可以并行下载,但js，css优先级高于图片）, 并行加载一个域名下会有最大值
2. 遇到css会阻塞Render Tree的渲染，,因为Render Tree需要css信息，但不会阻塞Dom tree的渲染;css 的加载也会影响 js 的执行,不影响加载
3. 而遇到Js，会使得html解析和渲染停止，直至js脚本加载并执行完毕才继续。

## html解析会回流和重绘
### 什么是回流和重绘
1. 当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新布局的。这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候。在回流的时候，浏览器会使渲染树中受到影响的部分失效，并重新构造这部分渲染树，完成回流后，浏览器会重新绘制受影响的部分到屏幕中，该过程成为重绘。
2. 当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如改变vidibility、outline、背景色等属性。这就叫称为重绘。
3. 回流必定重绘，重绘不一定回流

### 什么情况下会回流
1. 添加或者删除可见的DOM元素，display:none;；
2. 元素位置改变，即使元素已经浮动和脱离文档流（position：absolute）,但浮动和脱离文档流不会引起引起父元素以及后续元素频繁的回流
3. 元素尺寸改变——边距(margin)、填充(padding)、边框(border)、宽度(width)和高度(height)
4. 内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变；
5. 页面渲染初始化；
6. 浏览器窗口尺寸改变——resize事件发生时； 
7. 读取元素的某些属性(offsetLeft、offsetTop、offsetHeight、offsetWidth、getComputedStyle()等)

##### 回流的特点
1. 父节点的渲染树改变时，会触发子节点的重新计算，也会触发其后续兄弟节点的重排，但不会影响前面节点；例如：如果在body最前面插入一个元素，会导致整个文档的重新渲染，而在其后插入一个元素，则不会影响到前面的元素。
2. 浮动和脱离文档流不会引起引起父元素以及后续元素频繁的回流

### 会重绘的 css 属性
1. color
2. border-style
3. border-radius
4. visibility
5. text-deciration
6. background
7. backgroud-image
8. background-position
9. background-repeat
10. outline-color
11. outline
12. box-shadow

## 页面加载知识应用
1. 为什么我们要把css放在头部，js放在尾部。总的来说是减少网页阻塞，加快网页渲染，让一个美丽的网页尽快展示在客户面前。分开来说，第一JS是阻塞加载，而且一般是扮演事件处理的功能。这样的话，页面渲染的时候和JS没有关系；第二render树需要dom树和cssom树，如果css放在尾部，可能会导致页面会出现闪跳的感觉，布局样式丑乱的局面
2. 由于display属性为none的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排。如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发2次重绘。
3. 消耗最低的是transform和opacity两个属性，所以在制作动画时，建议使用transform的translate替代margin或position中的top、right、bottom和left，同时使用transform中的scaleX或者scaleY来替代width和height。