# js 事件执行机制
## js 的执行域，在这里我们只讨论浏览器
1. 浏览器是多进程的，通过开辟一个渲染进程，来渲染 html 文件，而渲染进程是多线程的。
2. 渲染进程常驻三个线程：GUI 负责渲染浏览器界面，解析HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等，当重排和重绘时，会开启 GUI 线程；js 引擎线程，就是我们称为 JS 的内核（例如 chrome V8 引擎），负责处理Javascript脚本程序；浏览器事件触发线程：当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。
3. GUI 线程和 JS 引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞;css 也会导致 js 阻塞。
4. Js 引擎是单线程执行的，无法同时执行多段代码。当某一段代码正在执行的时候，所有后续的任务都必须等待，形成一个队列。一旦当前任务执行完毕，再从队列中取出下一个任务，这也常被称为 “阻塞式执行”。
5. 当有事件触发时如setTimeOut、也可来自浏览器内核的其他线程如鼠标点击、AJAX异步请求等都会新建事件触发进程。

## js 引擎线程和事件触发进程配合对事件进行处理
1. 当 JS 引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中
2. 对应的事件符合触发条件被触发时，该事件触发线程会把事件添加到事件处理队列(Event Queue)的队尾，等待JS引擎的处理
3. 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行），所以setTimeout，setInterval 执行时间可能会不精确
4. 事件循环（Event Loop）：事件循环是指 js 引擎线程重复从事件处理队列中取消息，执行的过程。值得注意的是一轮事件循环只能取出一件事件来放到 js 引擎的执行栈(Stack)中。
5. 至此我们可以看出：同步任务都放入主线程的Stack当中，将异步和延时的任务都放入Event Queue里面等待执行

#### 事件循环代码展示

```
// 第一步
console.log(1);
// 第二步
setTimeout(() => {
    console.log(2)
}, 0)
// 第三步
console.log(3);
```

1. 输出顺序：1，3，2
2. 第一步和第三步都是 js 引擎的执行栈(Stack)中的事件，只有栈中的事件清空了，才会执行事件处理队列(Event Queue)中的事件
3. 第二步 setTimeout 把事件推入事件触发线程，即使延迟时间设置为 0，也只是把事件推入事件处理队列，而不是立即执行 

## ES6 新增了一个任务队列：微任务队列（microtasks queues）
1. 宏任务（macro task）：当前调用栈中执行的代码成为宏任务。（主代码快，定时器等等）。例如:整体代码，setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering，requestAnimationFrame
2. 微任务（micro task）：当前（此次事件循环中）宏任务执行完，在下一个宏任务开始之前需要执行的任务。值得注意的是所有的微任务都执行完毕，才会执行宏任务。例如: promise.thenk，process.nextTick，MutationObserve
3. 宏任务中的事件放在Event Queue中，由事件触发线程维护；微任务的事件放在微任务队列中，由js引擎线程维护。

#### 代码展示

```
console.log(1);
Promise.resolve().then(() => {
    console.log(2);
}).then(() => {
    console.log(3)
})
setTimeout(() => {
    console.log(4)
}, 0)
console.log(5);
```

1. 输出顺序：1，5，2，3，4
2. 先执行同步事件的顺序，在执行所有微任务2，3，最后再执行宏任务 4