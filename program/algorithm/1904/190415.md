# 算法：排序总结

## 排序算法总结
![](https://tomz-1253937763.cos.ap-guangzhou.myqcloud.com/img/201904/sort.png)

1. 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；
2. 不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；
3. 时间复杂度： 一个算法执行所耗费的时间。
4. 空间复杂度：运行完一个程序所需内存的大小
5. 最好情况：在最理想的情况下，执行这段代码的时间复杂度
6. 最坏情况：在最糟糕的情况下，执行这段代码的时间复杂度
7. n: 数据规模
8. k: “桶”的个数
9. In-place: 占用常数内存，不占用额外内存
10. Out-place: 占用额外内存

## 比较排序和非比较排序
1. 比较排序：常见的快速排序、归并排序、堆排序、冒泡排序等属于比较排序。在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。
2. 计数排序、基数排序、桶排序则属于非比较排序。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr之前有多少个元素，则唯一确定了arr在排序后数组中的位置。非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度O(n)。非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。

## 排序算法详解
1. [冒泡排序](https://www.tomz.club/blog/md/Pragram/algorithm/2019-04/190416.md)
2. [选择排序](https://www.tomz.club/blog/md/Pragram/algorithm/2019-04/190417.md)
3. [插入排序](https://www.tomz.club/blog/md/Pragram/algorithm/2019-04/190418.md)
4. [希尔排序](https://www.tomz.club/blog/md/Pragram/algorithm/2019-04/190419.md)
5. [计数排序](https://www.tomz.club/blog/md/Pragram/algorithm/2019-04/190420.md)
