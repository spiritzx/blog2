# 数据结构与算法 - 基础
## 自定义概念
所有的算法必须基于数据结构生存。也就是说，我们对于任何算法的编写，必须依赖一个已经存在的数据结构来对它进行操作，数据结构成为算法的操作对象（例如：数组的排序算法），这也是为什么算法和数据结构两门分类不分家的概念。

------
## 数据结构
> 数据结构这门学科就是为了让计算机能够以更加高效，简单，便捷的方式来存储和使用数据而产生的。所有的目标都围绕着存和取两个目标打转。在这两个目标下，有几个评估的指标，存取效率，可扩展性，顺序性，可排序性这几个特征。

#### 什么是数据结构
数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。

#### 常用的数据结构
1. 数组
2. 栈(先入后出)
3. 队列(先入先出)
4. 链表
5. 树
6. 散列表
7. 堆
8. 图

------
## 算法
#### 什么是算法
算法也可以理解为一个解题步骤，有一些基本运算和规定的顺序构成。但是从计算机程序设计的角度看，算法由一系列求解问题的指令构成，能根据规范的输入，在有限的时间内获得有效的输出结果。算法代表了用系统的方法来描述解决问题的一种策略机制。

#### 算法五个特征
1. 有穷性： 一个算法必须保证执行有限步之后结束；
2. 确切性： 算法的每一步骤必须有确切的定义；
3. 输入：一个算法有0个或多个输入（数据规模），以刻画运算对象的初始情况，所谓0个输入是指算法本身定除了初始条件；
4. 输出：一个算法有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的；
5. 可行性： 算法原则上能够精确地运行，而且人们用笔和纸做有限次运算后即可完成。

#### 常见的算法
1. 排序算法：冒牌排序、选择排序、插入排序、希尔排序、归并排序和快速排序
2. 查找算法：顺序查找和二分查找

#### 衡量算法的标准
##### 1. 时间复杂度：执行这个算法需要消耗多少时间，T(n) = O(f(n));
> 算法的时间复杂度和两个因素有关：算法中的最大嵌套循环层数；最内层循环结构中循环的次数。

###### 常见的时间复杂度
常数阶O(1)，对数阶O(log2n)，线性阶O(n)，线性对数阶O(nlog2n)，平方阶O(n2)，立方阶O(n3)， k次方阶O(nk)，指数阶O(2n)。随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。

###### 如何求时间复杂度
1. 如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)，如程序的输入输出、赋值等语句都近似认为需要O(1)时间。
2. 当有若干个循环语句时，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的频度f(n)决定的。
3. 算法的时间复杂度不仅仅依赖于问题的规模，还与输入实例的初始状态有关。
4. 简单语句：程序的输入输出、赋值等语句都近似认为需要时间。
5. 顺序结构：需要依次执行一系列语句所用的时间可采用O()的"求和法则"，
6. 选择结构：如if语句,它的主要时间耗费是在执行else字句所用的时间,需注意的是检验条件也需要时间。
7. 循环结构：循环语句的运行时间主要体现在多次迭代中执行循环体以及检验循环条件的时间耗费,一般可用O()的"乘法法则"。
8. 复杂算法：将其分成几个容易估算的部分,然后利用求和法则和乘法法则计算整个算法的时间复杂度。
9. 用常数1取代运行时间中的所有加法常数。例如：(T(n) = O(f(2n2 + 3n + 3)) => T(n) = O(f(2n2 + 3n + 1)))
10. 在修改后的运行次数函数中，只保留最髙阶项。例如：(T(n) = O(f(2n2 + 3n + 1)) => T(n) = O(f(2n2)))
11. 如果最高阶项存在且不是1,则去除与这个项相乘的常数。 例如：(T(n) = O(f(2n2)) => T(n) = O(f(n2)))

###### 时间复杂度效率排名
> O(1) 常数阶 < O(logn) 对数阶 < O(n) 线性阶 < O(nlogn) nlogn阶 < O(n^2) 平方阶 < O(n^3) 立方阶 < { O(2^n) < O(n!) < O(n^n) }

1. 立方阶以后的算法效率不可用，执行效率越低

------
##### 2. 空间复杂度：这个算法需要占用多少内存空间，记做 S(n)=O(f(n)) 
> 算法的时间运行效率才是最重要的。只要算法占用的存储空间不要达到计算机无法接受的程度即可。所以，常常通过牺牲空间复杂度来换取算法更加高效的运行时间效率。

###### 如何求空间复杂度
1. 多开常数空间（不开）：O(1)
2. 多开一个辅助的数组：O(N)
3. 多开一个辅助的二维数组：O(N^2)

------
## 其他
1. In-place：不占用额外内存或占用常数的内存
2. Out-place：占用额外内存
3. 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；
4. 不稳定：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；
5. 当需要对大量数据进行排序时，In-place sort就显示出优点，因为只需要占用常数的内存。
6. 设想一下，如果要对10000个数据排序，如果使用了Out-place sort，则假设需要用200G的额外空间，则一台老式电脑会吃不消，但是如果使用In-place sort，则不需要花费额外内存。