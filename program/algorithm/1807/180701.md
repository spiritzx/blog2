# 算法：递归算法
> 函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。

## 形成条件
1. 子问题须与原始问题为同样的事，且更为简单；
2. 不能无限制地调用本身，必须有个出口，边界条件

## 递归理解
1. 每一次递归调用，都用一个特殊的数据结构"栈"记录当前算法的执行状态，特别地设置地址栈，用来记录当前算法的执行位置，以备回溯时正常返回。
2. 或者说是“链表”，自身就是指针指向下一阶段，例如阶乘可以看作：

```
// 3*2*1;
value: 3,
fact(2): {
    value: 2,
    fact(1): {
        value: 1
    }
}
// fact(3)*fact(2)*fact(1)

```

3. 从代码上来说是进行函数的循环

## 缺点
1. 递归算法解题相对常用的算法如普通循环等，运行效率较低。
2. 递归次数过多容易造成栈溢出等。

## 应用
1. 阶乘 n!

```
// 使用循环
for (let i = _num; i >= 2; i--) {
    _num = _num*(i-1);
}

// 使用递归
function fact(n) {
    if (n === 1 || n === 0) { // 边界条件
        return 1; 
    }
    else {
        return n*fact(n-1)
    }
}

```

### 解析
以n=3为例，看运行过程如下： 

```
fact(3) ----- fact(2) ----- fact(1) ------ fact(2) -----fact(3) 
------------------------------> ------------------------------> 
递归                             回溯 
```

递归算法在运行中不断调用自身降低规模的过程，当规模降为1，即递归到fact(1)时，满足停止条件停止递归，开始回溯(返回调用算法)并计算，从fact(1)=1计算返回到fact(2);计算 2 * fact(1)=2 返回到fact(3)；计算3*fact(2)=6，结束递归。 算法的起始模块也是终止模块。


