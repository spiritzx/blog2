
# electron 不在支持 remote 的原因
> 技术文档翻译; 由 electron 维护团员 Jeremy Rose 发表

自从最早的 Electron 版本开始，remote 模块就成为在主进程与渲染进程之间进行通信的首选工具。基本前提是：从渲染器进程中，您可以请求主进程中提供 remote。然后，您可以使用该 remote，就像它是渲染器过程中的普通 JavaScript 对象一样，等待 promise 和注册事件处理程序。渲染进程和主进程之间的所有 IPC 调用都在后台为您处理。超级方便！但 remote 他有以下缺点:

####  1. 慢
由于是 remote 实现类似于 Java 中的 RMI,也就是相当于通信协议请求,造成了访问远程对象上的属性的平均时间约为0.1毫秒。为了进行比较，访问渲染器本地对象上的属性大约需要0.00001毫秒（重复）。远程对象比本地对象慢一万倍

#### 2. 卡
当渲染器进程访问 remote（例如读取属性或调用函数）时，渲染器进程会向主进程发送一条消息，要求其执行该操作，然后阻止等待响应。这意味着，在渲染器等待结果的同时，它只能在那等待。没有解析传入的网络数据，没有渲染，没有处理计时器。它只是在等待。

#### 3. remote 对象与常规对象略有不同。
1. 原型链不会在进程之间传递。因此，例如，remote.getGlobal（'foo'）.constructor.name ===“ Proxy”，而不是远程构造函数的真实名称。如果涉及到原型的任何东西碰触到 remote ，都会保证爆炸。
2. remote 未正确处理 NaN 和 Infinity。如果 remote 的函数返回NaN，则渲染器进程中的 remote 将返回undefined。
3. 从渲染器进程中运行的回调返回的值不会传递回主进程。当您将函数作为回调传递给远程方法时，无论渲染器进程中的方法返回什么，从主进程调用该回调将始终返回undefined。这是因为主进程无法阻止等待渲染器进程返回结果。

#### 4. remote 可能是个安全漏洞
remote 在 electron 线程安全边界上撕开了一个大孔,会让漏洞影响主进程

#### 5. remote 对象源代码维护困难
防止 remote 被垃圾回收需要大量代码,且如果 remote 出现 bug,修复及其困难

## 如何替代 remote
因此，您应该最大程度地减少应用程序中 IPC 通信的使用-最好在渲染过程中尽可能多地保留工作。如果需要在不同来源的窗口之间进行通信，请使用 postMessage。



