# electron 不在支持 remote 的原因
> 技术文档翻译; 由 electron 维护团员 Jeremy Rose 发表

自从最早的 Electron 版本开始，remote 模块就成为在主进程与渲染进程之间进行通信的首选工具。基本前提是：从渲染器进程中，您可以请求主进程中提供 remote。然后，您可以使用该 remote，就像它是渲染器过程中的普通 JavaScript 对象一样，等待 promise 和注册事件处理程序。渲染进程和主进程之间的所有 IPC 调用都在后台为您处理。超级方便！但 remote 他有以下缺点:

####  1. 慢
基于 Chromium 的 Electron 继承了Chromium的多进程模型。有一个或多个渲染器进程，它们负责渲染HTML / CSS并在页面上下文中运行JS，而一个主进程则负责协调所有渲染器并代表它们执行某些操作。

当渲染器进程访问 remote（例如读取属性或调用函数）时，渲染器进程会向主进程发送一条消息，要求其执行该操作，然后阻止等待响应。这意味着，在渲染器等待结果的同时，它只能在那等待。没有解析传入的网络数据，没有渲染，没有处理计时器。它只是在等待。

在我的机器上，访问远程对象上的属性的平均时间约为0.1毫秒。为了进行比较，访问渲染器本地对象上的属性大约需要0.00001毫秒（重复）。远程对象比本地对象慢一万倍。我把它放在大文本中，因为它很重要。


#### 2. 创造了一些混淆计时问题的可能性
例如当你调用 remote 注册的一个函数 F1,然后在主函数监听该函数 F1 执行的结果.如果函数 F1 执行的够快,可能主函数监听不到该事件的结果.

#### 3. remote 对象与常规对象略有不同。
1. 原型链不会在进程之间传递。因此，例如，remote.getGlobal（'foo'）.constructor.name ===“ Proxy”，而不是远程构造函数的真实名称。如果涉及到原型的任何东西碰触到 remote ，都会保证爆炸。
2. remote 未正确处理 NaN 和 Infinity。如果 remote 的函数返回NaN，则渲染器进程中的 remote 将返回undefined。
3. 从渲染器进程中运行的回调返回的值不会传递回主进程。当您将函数作为回调传递给远程方法时，无论渲染器进程中的方法返回什么，从主进程调用该回调将始终返回undefined。这是因为主进程无法阻止等待渲染器进程返回结果。

#### 4. remote 可能是个安全漏洞
remote 在 electron 线程安全边界上撕开了一个大孔,会让漏洞影响主进程

#### 5. remote 对象源代码维护困难
防止 remote 被垃圾回收需要大量代码,且如果 remote 出现 bug,修复及其困难

## 如何替代 remote
因此，您应该最大程度地减少应用程序中 IPC 通信的使用-最好在渲染过程中尽可能多地保留工作。如果需要在不同来源的窗口之间进行通信，请使用 postMessage。



